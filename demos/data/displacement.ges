#version 400 core

uniform mat3 u_normal_matrix;

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

in vec3 te_pos[3];
in vec2 te_texcoord[3];
in vec3 te_normal[3];
in vec3 te_tangent[3];
in vec3 te_patch_distance[3];


out vec2 g_texcoord; // texture coords
out vec3 g_normal;
out vec3 g_tangent;  // tangent
out vec3 g_binormal; // binormal (for TBN basis calc)

out vec3 g_patch_distance;
out vec3 g_tri_distance;


void main()
{
    vec3 A = te_pos[2] - te_pos[0];
    vec3 B = te_pos[1] - te_pos[0];
    g_normal = u_normal_matrix * normalize(cross(A, B));
	g_tangent = u_normal_matrix * normalize(A);
	g_binormal = cross(g_normal, g_tangent);

    g_patch_distance = te_patch_distance[0];
	g_texcoord = te_texcoord[0];
    g_tri_distance = vec3(1, 0, 0);
    gl_Position = gl_in[0].gl_Position; EmitVertex();

    g_patch_distance = te_patch_distance[1];
	g_texcoord = te_texcoord[1];
    g_tri_distance = vec3(0, 1, 0);
    gl_Position = gl_in[1].gl_Position; EmitVertex();

    g_patch_distance = te_patch_distance[2];
	g_texcoord = te_texcoord[2];
    g_tri_distance = vec3(0, 0, 1);
    gl_Position = gl_in[2].gl_Position; EmitVertex();

    EndPrimitive();
}
